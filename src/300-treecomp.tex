% !TEX root = document.tex

\chapter{\label{chap:commandtree}Command Trees}
To obtain a more modular approach for representing compiler transformations we introduce command trees\autocite{commandtreespoulsen}. Additionally, command trees allow us to express the \ac{CPS} conversion of a language in a descriptive (denotational) manner. Command trees are implemented using Haskell \acp{GADT}. A \ac{GADT} gives us the power to add more types to our \ac{IR}.

\begin{lstlisting}[language=Haskell]
data Tree sig a where
  Leaf :: a -> Tree sig a
  Node :: sig n b p r q ->
          Vec n (p -> Tree sig r) ->
          Option b (q -> Tree sig a) ->
          Tree sig a
\end{lstlisting}

On a high level command trees are a way to sequence commands. A well known data structure that is also capable of this is a list. Command trees improve upon lists by adding types that restrict its structure and the ability to use the result of one command in the commands after that. Just like lists, command trees are monads. This allows us to bind command trees together easily and write functions using command trees with monadic sugar. Commands are a syntactic representations of a monadic computations. In simpler terms this can be described as the meaning of a command is something that is left to the programmer. What a command does is implemented later in a function sometimes called a handler.

The structure and monadic nature of command trees have already been discussed in \citetitle{commandtreespoulsen}. A modified version of the discussion will be restated here for completeness. A command tree consists of two constructors: \lstinlineb{Leaf} and \lstinlineb{Node}. \lstinlineb{Leaf v} is the smallest form of command tree that exists and simply returns the value \lstinline{v}. A \lstinlineb{Node op vs k} command tree is somewhat more complex and is made up of three parts:

\begin{itemize}
\item An operation \lstinlineb{op} with signature \lstinlineb{sig},
\item A dependently typed vector of subcontinuations \lstinlineb{vs},
\item An optional continuation (also called join-point) \lstinlineb{k}.
\end{itemize}

A command tree does not know what set of commands is used. However, it does encode strong type constraints on its subcontinuations and continuation. To enforce these constraints we use a signature \lstinlineb{sig}. This way a command tells the command tree what comes after itself. More formally a signature has type:

\begin{lstlisting}[language=Haskell]
sig :: Nat -> Bool -> * -> * -> * -> *
\end{lstlisting}

A signature instance \lstinlineb{sig n b p r q} tells us the following things:

\begin{itemize}
\item The tag of the command and its enclosed parameters.
\item The number of subcontinuations \lstinlineb{n}.
\item If the command has a continuation.
\item The argument \lstinlineb{p} and return type \lstinline{r} of the subcontinuations.
\item The argument type \lstinline{q} of the continuation.
\end{itemize}

\section{\label{section:opmonad}The operational monad}
Although not necessary to understand the usefulness and implementation of command trees for use in the LamToWat compiler, we will give some history and background on the datatype. The paper \citetitle{DBLP:conf/haskell/KiselyovI15} gives a derivation of the freer monad, a close relative of the command tree. We follow a similar style. The main problem the command tree and its relatives address is: expressing side-effectful computation in a composable/modular manner. We will start by unpacking this definition.

A side-effect can be understood as an interaction of an expression with its context\autocite{DBLP:conf/tacs/CartwrightF94}. A concrete example is the communication between a number of clients and a central server. A side-effect is a request from a client to the server. This can be a request for some data or an action. From this it follows immediately that we can model side effects with datatypes that specify such a request. A trivial example is a ping request.

\begin{lstlisting}[language=Haskell]
data Request = Ping
\end{lstlisting}

% use results of computation
The result of the ping request may be used in another part of the program. Our \lstinlineb{Request} datatype does not indicate what the return type of a ping request will be. Moreover, there is no place where the reply of the request is bound. We can define a datatype that helps us with both these problems. We will call it \lstinlineb{Compute}.

\begin{lstlisting}[language=Haskell]
data Compute = Done Int | Compute Request (Int -> Compute)
\end{lstlisting}

\lstinlineb{Compute} has two constructors that have the same role as those of the command tree. The \lstinlineb{Done} constructor represents a computation without side effects that return an integer. \lstinlineb{Compute} binds \lstinlineb{Request}s together. The result of a request is an integer and may be used in the following computations. An example shows the datatypes in action. We send two sequential ping requests to the central server and bind them to the variables \lstinlineb{i} and \lstinlineb{j}. Finally, we return the average of both. How a ping request is actually implemented is left open. \lstinlineb{Request} just provides the interface for effectful computation.

\begin{lstlisting}[language=Haskell]
pingtwiceavg = Compute Ping (\ i -> Compute Ping (\ j -> Done ((i + j) `div` 2)))
\end{lstlisting}

This way of defining sequences of effectful computations is called operational\autocite{operationalmonad}. It is an alternative to other monadic implementations of side-effects. The upside of operational monads is their compositional nature. Traditional implementation of side-effects such as monad transformers\autocite{DBLP:conf/popl/LiangHJ95} also compose, but suffer from non-commutative behavior\autocite{DBLP:conf/ifl/DayH13}.

Haskell provides typeclasses for defining monads. Our \lstinlineb{Compute} datatype does not qualify for these, because Haskell requires monads to be parameterized over a type. We define our own \lstinlineb{bind} function, which composes two computations; the \lstinlineb{unit} function creates a trivial computation. In the implementation of the \lstinlineb{bind} function we see that it pushes a function from an integer to a computation into the continuation of a computation. This is similar to list concatenation.

\begin{lstlisting}[language=Haskell]
bind (Done i) f = f i
bind (Compute r k) f = Compute r (\ i -> bind (k i) f)
-- unit is trivial
unit = Done
\end{lstlisting}

With our monadic definitions in place we can create a pretty version of our previous program that takes the average ping. We will define a helper function that represent a program that sends a ping request and returns the result. This enables us to \lstinlineb{bind} these smaller programs together.

\begin{lstlisting}[language=Haskell]
ping = Compute Ping Done

prettyping =
  ping `bind` \ i ->
  ping `bind` \ j ->
  unit ((i + j) `div` 2)
\end{lstlisting}

\subsection{\label{section:freemonad}Free monad}
Both the command tree and the \lstinlineb{Compute} datatype are a specialization of the free monad\autocite{swierstra2008data}. The free monad arises naturally when composing functors. In mathematical terms a functor is a mapping between categories\autocite{barr1990category}. In practical terms a functor is something that can mapped over. A list is a functor. We will take as example functor a modified version of the \lstinlineb{Maybe} datatype and show what happens when we compose it with itself\autocite{freemonadsforall}. It describes a programming language where we either \lstinlineb{Stop} with execution or sound a \lstinlineb{Bell} and continue.

\begin{lstlisting}[language=Haskell]
data Program a = Stop | Bell a

p0 :: Program (Program a)
p0 = Bell Stop

p1 :: Program (Program (Program a))
p1 = Bell (Bell Stop)
\end{lstlisting}

We see that our type grows with our expression. Both \lstinlineb{p0} and \lstinlineb{p1} should have the type \lstinlineb{Program a}. We want a function of type \lstinlineb{Program (Program a) -> Program a} that removes the nesting of functors. What we need is a fixpoint of a functor.

\begin{lstlisting}[language=Haskell]
data Fix f where
  Fix :: f (Fix f) -> Fix f
\end{lstlisting}

The type of \lstinlineb{Fix} reflects the type of the function that we wanted. Our new programs will be of type \lstinlineb{Fix Program}.

\begin{lstlisting}[language=Haskell]
fp0 :: Fix Program
fp0 = Fix (Bell (Fix Stop))

fp1 :: Fix Program
fp1 = Fix (Bell (Fix (Bell (Fix Stop))))
\end{lstlisting}

\lstinlineb{Fix} is almost a monad. What we need is a generic way to terminate programs. We will also need to parameterize over a type instead of a functor. This leads us to the free monad.

\begin{lstlisting}[language=Haskell]
data Free f a where
  Pure   :: a            -> Free f a
  Impure :: f (Free f a) -> Free f a
\end{lstlisting}

The free monad is thus a way to nest a functor, while maintaining a basic type of that functor. The free monad is restricted by this functor requirement. Without it, it is not a monad. Command trees do not have this requirement. We use a wrapper for our commands that ensures they are functors. This wrapper is a complex functor, but the principle is based on a simpler concept: pretending a mapping happened. The datatype that captures this notion is the functor by construction \lstinlineb{F}. It consists of something resembling a functor and a mapping over the contents of this fake functor. Whenever we map over \lstinlineb{F}, we simply compose with the second argument. We pretend something happened; we update our mapping function.

\begin{lstlisting}[language=Haskell]
data F f a where
  F :: f a -> (a -> b) -> F f b
\end{lstlisting}

\section{\label{section:cpscommands}CPS commands}
Without commands we can not do anything with our command trees. We will use a set of commands that reflect the constructors from the \ac{CPS} datatype. We also define a number of extra commands that will help us compile. Just as in section \ref{section:opmonad} we will add sugar to our commands. This progamifying or treeifying of a command or request is called lifting. This is called so because we 'lift' the expression into the monad.

\begin{lstlisting}[language=Haskell]
data Cmd :: Nat -> Bool -> * -> * -> * -> * where
  -- cps commands
  Fix    :: Vec n (Var, [Var]) -> Cmd n       'True  ()    Val   ()
  App    :: Val -> [Val] ->       Cmd 'Z      'False Void  Void  Val 
  Plus   :: Val -> Val ->         Cmd 'Z      'True  Void  Void  Val
  Record :: [Val] ->              Cmd 'Z      'True  Void  Void  Val
  Select :: Int -> Val ->         Cmd 'Z      'True  Void  Void  Val
  -- extra compilation commands
  Get    :: Var ->                Cmd 'Z      'True  Void  Void  Val
  Put    :: Var -> Val ->         Cmd 'Z      'True  Void  Void  ()
  Block  ::                       Cmd ('S 'Z) 'True  ()    Val   Val
  Fresh  :: Var ->                Cmd 'Z      'True  Void  Void  Var
\end{lstlisting}

We can see that almost all our original constructors from the \ac{CPS} datatype are here. Except the \lstinlineb{DONE} constructor. This constructor will be modeled by the \lstinlineb{Leaf} of the command tree. The \lstinlineb{Var} and \lstinlineb{Val} type are the same as in \ac{CPS}. Our four extra commands represent state, help with command concatenation, and generate fresh variables. You may note that these operations can be implemented using standard Haskell monads (like the state monad). However, this would lead to using monad transformers on the tree itself, while also needing to produce a tree as a result, preventing us from exploiting the monadic nature of the command tree. This embedding leads to more declarative code.

We take a look at the signatures of the commands to see how they are structured. The \lstinlineb{Block} and \lstinlineb{Fix} command are the only ones that have subcontinuations. The \lstinlineb{Void} types show that when there is no subcontinuation, these subcontinuations will not have any members. \lstinlineb{Fix} has a subcontinuation for every function definition. This is required by the constructor itself as the natural number \lstinlineb{n} appears in both the function name with arguments and subcontinuations. The \lstinlineb{App} command does not have a continuation, which will lead to some trouble when trying to concatenate it with other commands. The return type of commands indicates that commands will bind to a variable \lstinlineb{Val} or only produce a side-effect \lstinlineb{()}.

\subsection{\label{section:impcpsconvert}Improved CPS conversion}
Using the \ac{CPS} commands, we can define an improved \ac{CPS} conversion. It is improved in the sense that it specifies a denotational semantics\autocite{DBLP:conf/tacs/CartwrightF94} of the language it converts. There are some details that spoil the declarativity of our conversion somewhat. The advantages and disadvantages of our new approach become clear when we examine the conversion of an abstraction in comparison to the one listed in section \ref{section:cpsconvert}. We use the sweet version of our commands.

\begin{lstlisting}[language=Haskell]
denote (Abs x e) = do
  f <- fresh ".f"
  k <- fresh ".k"
  fix ((f,[x,k],do
           e <- denote e
           app (VAR k) [e])
       ::: Nil)
  return (LABEL f)
\end{lstlisting}

We generate a fresh function variable \lstinlineb{f} and continuation variable \lstinlineb{k}. We use these variables to create a function with name \lstinlineb{f} that has as argument the original variable and a continuation named \lstinlineb{k}. The body of the function will be the converted original body and a final statement that applies the continuation to the resulting variable. We finally return the function name wrapped in a \lstinlineb{LABEL}.

We no longer have a metacontinuation argument in our conversion function. This simplifies the notation significantly. We still operate in a monad, however, this monad is the command tree, not the state monad. The order of our listed operations matches the order of our final program more closely.

% TODO
% better advantages / disadvantages

\section{\label{section:transcomtree}Transforming command trees}
After we have performed our \ac{CPS} conversion our code lives inside a command tree. We will now have to perform the transformations on the original \ac{CPS} datatype on the command tree. The abstract nature of command trees prevents us from defining these functions without escaping from its abstraction. The fundamental problem is that continuations are defined as functions in the metalanguage instead of syntactic constructs in the \ac{IR} itself.

The next step in the compiler is closure conversion. To define closure conversion, we first need to write a helper function that makes a map of free defined variables for each function. Here our command tree breaks down, because variables are part of the metalanguage. We examine the case for addition. In the old version we could update our variable list with the name \lstinlineb{x} that was part of the \lstinlineb{ADD} expression itself. In the new version our variable name is hidden inside the continuation \lstinlineb{k}, which has type \lstinlineb{Val -> Tree Cmd Val}. If we want to access our continuation, we will have to generate a fresh variable name to apply it to. However, we would need the same generated variables again in the actual closure conversion. This is simply not practical. We need a syntactic embedding of variable binding in our \ac{IR} in order to perform closure conversion.

\begin{lstlisting}[language=Haskell]
-- old dv function
dv (ADD _ _ x k) xs = dv k (x:xs)
-- new dv function
dv (Node (Plus _ _) Nil (Some k)) xs = _
\end{lstlisting}

% TODO
% dv function kaput
% generate variables is broken

% from good to bad
% command trees
% - improved version with command trees
%   - bridge: conversion function, hard to type the IRs without explosion
% - explain free monads in the blog post again
% - how is it going to help with the problem
% *use monadic sugar from haskell (denotation function)*
%   - modular optrees for subsets of signatures
% 
% how transformation on themselves?
% does not work...
% The modularity of commands will provide us with the ability to make transformations explicit in the datatype without much boilerplate.