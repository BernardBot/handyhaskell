% !TEX root = document.tex

\chapter{\label{chap:compiler}The LamToWat compiler}
The LamToWat compiler is a \ac{WA} compiler for the call-by-value, untyped lambda calculus with addition and numbers, implemented in Haskell. It is not meant to be an efficient compiler. The purpose of the compiler is to study different \acp{IR}. Multiple passes over the \ac{IR} will be made, each transforming a part of the representation. The complete compiler comprises these \ac{IR} transformations with additional passes to read in source files and print the resulting \ac{WA}.

% TODO: make this better
\begin{gather*}
  \mbox{source} \xrightarrow{\mbox{lexing}} \mbox{tokens} \xrightarrow{\mbox{parsing}} \mbox{lambda} \xrightarrow{\mbox{cps conversion}} \\
  \mbox{cps} \xrightarrow{\mbox{closure conversion}} \mbox{cc-cps} \xrightarrow{\mbox{hoisting}} \mbox{hoisted-cc-cps} \xrightarrow{\mbox{emitting}} \\
  \mbox{abstract WA} \xrightarrow{\mbox{printing}} \mbox{WA}
\end{gather*}

The multiple passes of the LamToWat compiler are split into a front-end and a back-end. The front-end of the compiler is made up of lexing, parsing, and \ac{CPS} conversion. We will not discuss lexing and parsing in detail, as it is irrelevant to the research in this thesis. We use \lstinlineb{Alex}\autocite{haskellalex} and \lstinlineb{Happy}\autocite{haskellhappy} to generate both a lexer and a parser for our compiler, respectively. These tools are also used in the front-end of \ac{GHC}. The lexer converts source files into tokens and the parser in turn converts these tokens into an \ac{AST}. The back-end of the LamToWat compiler consist of three transformations on the \ac{IR}: closure conversion, hoisting, and emitting.

% TODO explain sections

\section{\label{section:cpsconvert}CPS conversion}
\ac{CPS} conversion will transform the lambda calculus \ac{AST} into the \ac{CPS} datatype listed in section \ref{section:cwc}. LamToWat uses a Haskell datatype to represent the \ac{AST} of the lambda calculus with addition. There are five constructors in total corresponding to: function abstraction, application, variables, numbers, and addition. Variables are represented by strings and numbers are integer constants. It is obvious that this datatype is not in \ac{CPS}: the application constructor takes non-value expressions. Note that we could define a \ac{CPS} conversion on the datatype itself, but prefer the syntactic constraints from our own \ac{CPS} datatype.

\begin{lstlisting}[language=Haskell]
type Var = String

data Exp
  = Abs Var Exp
  | App Exp Exp
  | Var Var
  | Num Int
  | Add Exp Exp
\end{lstlisting}

\ac{CPS} conversion gives all intermediate variables a name and makes control flow explicit. This is a very abstract notion of what we need to do. In practice we will have a monad to generate fresh variable names and a metacontinuation to manage control flow. The conversion effects only the part of the lambda language that has nested expressions. This means function abstraction, application, and addition. We will convert the sub-expressions, give them a name and construct an expression in the \ac{CPS} language with these fresh names. How conversion actually works becomes clearer when illustrated with an example of converting function abstraction.

\begin{lstlisting}[language=Haskell]
convert (Abs x e) c = do
  f <- fresh "f"
  k <- fresh "k"
  c' <- c (LABEL f)
  cf <- convert e (\ z ->
         return $ APP (VAR k) [z])
  return $ FIX [(f,[x,k],cf)] c'
\end{lstlisting}

Here we show a part of the \lstinlineb{convert} function. In this case it converts a lambda abstraction to \ac{CPS}. It uses monadic sugar to bind statements together. We generate two fresh variables \lstinlineb{f} and \lstinlineb{k} for the function name and one for the continuation of the body of the function. The metacontinuation \lstinlineb{c} is passed the freshly generated name of our function. The \lstinlineb{LABEL} constructor is used to indicate that the variable references a function. Then we convert the body of our function and bind the result to \lstinlineb{z}, to which the continuation \lstinlineb{k} is applied. We can finally construct our recursive function binding. Note the extra argument \lstinlineb{k}.

\begin{lstlisting}[language=Haskell]
> cpsify (Abs "x" (Num 42))

def .f0(x,.k1):
  .k1(42)
_.f0
\end{lstlisting}

We give an example of the \ac{CPS} conversion in action to see how it works. We show a pretty printed version of the \ac{CPS} datatype. Our converted function is given the name \lstinlineb{.f0}. It still has the argument \lstinlineb{x} and an extra continuation argument \lstinlineb{.k1}. The result of the function body is passed to the continuation \lstinlineb{.k1}. The function name is the final expression of the converted program. It is a label for a function, and thus prefixed with an underscore.

\section{\label{section:closconvert}Closure conversion}
The lambda calculus has higher-order, nested functions. In order to represent these in \ac{WA} we perform closure conversion on \ac{CPS}. Closure conversion makes sure that functions no longer contain free variables. We package both a function pointer and its respective free variables in what is called a closure. Our function applications and function definitions will change. When we apply a closure we extract the function pointer and then apply it to both the closure itself and its original arguments. Functions will take an extra argument, which we name the environment. This argument will be a record containing all the free variables of the function. In the function body these variables will be extracted from the record and thus become available in the function body scope. When a function is passed as an argument we will need to pass a closure instead.

Determining the free variables of a function in \ac{CPS} is not trivial. \ac{CPS} has mutually recursive function definitions in the \lstinlineb{FIX} expression. When one functiion is used inside another function, the free variables of the enclosed function need to be added to the free variables of the enclosing function. There can even be circular dependencies between functions. For example: function f encloses function g, function g encloses function h, and function h encloses function f. This problem can be solved by live variable analysis\autocite{DBLP:books/aw/AhoSU86}. LamToWat simplifies the problem significantly by instead of determining the smallest set of free variables in a function, it takes all variables that are defined at the point of function definition substracted by the function's arguments. These variables we will call 'free defined variables' in order to distinguish them from the more general free variables. This simplification comes at a cost: bigger closures. Bigger closures require more space on the heap and we will need more operations to manipulate their contents. Before we closure convert we construct a map of function names to free defined variables. We then use this map every time we encounter a function variable indicated with \lstinlineb{LABEL}.

\begin{lstlisting}[language=Haskell]
> closify $ cpsify  (Abs "x" (Num 42))

def .f0(.env,x,.k1):
  .k1_F <- .k1 !! 0
  .k1_F(.k1,42)
.f0_C <- [_.f0]
.f0_C
\end{lstlisting}

We show how to closure convert our example function \lstinlineb{\ x -> 42}. Our function \lstinlineb{.f0} takes the extra environment argument \lstinlineb{.env}. The first thing that happens in the function body is extraction of the first element of the environment. This will be a function pointer, which is then immediately applied to itself and the original argument 42. After the function definition we see closure creation. The closure variable has the \lstinlineb{_C} suffix and in our case consists only of a function pointer. The final expression is the closure variable.

\section{\label{section:hoist}Hoisting}
After our functions have been closure converted we can hoist all function definitions to the top level. This will transform our program into a single mutually recursive function definition with one expression. Hoisting is a non-local transformation: the entire expression tree is affected. The implementation of this function makes heavy use of recursion.

\section{\label{section:emit}Emitting}
The emit transformation is quite trivial at the constructor level, as our \ac{IR} has been sufficiently transformed to match the structure of a \ac{WA} module. There are some small details that need to be addressed in order for the program to execute properly. Before we can print \ac{WA} we transform our closure converted, hoisted \ac{CPS} into an abstract representation of \ac{WA} in Haskell. This gives us some guarantees about the structure of our program before printing it. The abstract \ac{WA} datatype is a subset of all \ac{WA} expressions. A \ac{WA} module consist of a list of \ac{WA} statements. \ac{WA} statements (sometimes called top expressions) consist of \ac{WA} expressions, variables, integers, and types. \ac{WA} expressions consist of integers, variables, and \ac{WA} expression.

\ac{WA} is a typed assembly language. What this means is that functions will have a type signature. There are four base types in \ac{WA}: 32-bit integers, 64-bit integer, 32-bit floats, and 64-bit floats. Abstract \ac{WA} narrows this down to one: 32-bit integers. This type used as both a normal number and a pointer. At compile time the types of all variables that are in function position need to be known. \ac{CPS} will call functions dynamically. \ac{WA} has a special call instruction for this named \lstinlineb{Call_Indirect}. This instruction is given an extra argument: the type of the dynamically called function variable. Generating these types is easily done, as all our function arguments are of the base type. This is because both numbers, functions, and records are represented with 32-bit integers. All our functions will return a 32-bit integer. At every call site we count the number of arguments to generate the correct type. For example: a variable \lstinlineb{f} called with three arguments would result in the type \lstinlineb{(i32,i32,i32) -> i32}.

Another detail of \ac{WA} is that all locally used variables and their types need to be declared in the function signature. Local variables are determined with an auxillary function. We can then generate the required signature by combining all variables with the 32-bit integer type.

Records will be represented by integer pointers. Their elements will be allocated on the heap. We will need to keep track of which part of the heap is still free to allocate new records. We use a global heap pointer that gets incremented everytime a new record is put on the heap. There is no garbage collection. Thus if a program runs long enough the heeap will become full leading to a crash with a heap exhaustion error. 

\section{\label{section:transdata}Transformations as datatypes}
The transformation in the back-end of the LamToWat compiler change the structure and properties of the \ac{IR}. To make these transformations more explicit we can use three different datatypes: the original \ac{CPS} datatype, a closure converted datatype, and a hoisted datatype. The transformations themselves do not change significantly, but their qualities are confirmed by the datatypes.

Instead of representing closures by records we introduce two new constructors: \lstinlineb{CLOSE} and \lstinlineb{OPEN}. They represent the creation and destruction of closures. They contain the function pointer and free variables of a function.

By separating our mutually recursive function definition expression from the rest of the expressions, we can enforce the unnesting of functions. Since this datatype is used after the closure conversion transformation, we will need to include the \lstinlineb{CLOSE} and \lstinlineb{OPEN} constructors as well.

