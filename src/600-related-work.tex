% !TEX root = document.tex

\chapter{\label{chap:related-work}Related work}

Related work here.

\section{\label{section:cpstype}Typing CPS}
% cps type system
In section \ref{section:cwc} we have given a syntactic definition of the \ac{CPS} language. The datatype allows us to define bogus programs, e.g., a program that adds two recod values. In this section we will define more precisely what constitutes a valid program. In order to do this we will give the static semantics of the \ac{CPS} datatype by way of typing rules\autocite{DBLP:conf/popl/MorrisettWCG98, DBLP:conf/pldi/Chlipala07}.

\begin{equation*}
t ::= int \quad | \quad \overline{t} \to int \quad | \quad [t_1, \dots, t_n]
\end{equation*}

We have a small type language consisting of integers, arrows, and records. Because functions are just jumps, our arrow function reflects this by stating that functions do not return values, but lead to a final integer result. Record types are simply products of types.

\begin{equation*}
\frac{}{\vdash \lstinlineb{NUM} \, i : int} \quad \frac{\Gamma \vdash x : t}{\Gamma \vdash \lstinlineb{VAR} \, x : t} \quad \frac{\Gamma \vdash f : \overline{t} \to int}{\Gamma \vdash \lstinlineb{LABEL} \, f : \overline{t} \to int}
\end{equation*}

The typing judgement $\Gamma \vdash e$ indicates that expression or value $e$ is well typed in the environment $\Gamma$. Typing judgements for values are straightforward. \lstinlineb{NUM} has an integer type and \lstinline{VAR} has the type of the variable it contains. The only interesting value is \lstinlineb{LABEL}, which can exclusively hold variables that have a function type.

\begin{gather*}
\Gamma, f_1 : \overline{t_1} \to int, \dots, f_n : \overline{t_n} \to int, x_{i_1} : t_{i_1}, \dots, x_{i_{m_i}} : t_{i_{m_i}} \vdash e_i \\
\frac{\Gamma, f_1 : \overline{t_1} \to int, \dots, f_n : \overline{t_n} \to int \vdash e}{\Gamma \vdash \lstinlineb{FIX} [(f_1, [x_{1_1}, \dots, x_{1_{m_1}}], e_1), \dots, (f_n, [x_{n_1}, \dots, x_{n_{m_n}}], e_n)] \, e} \\ \\
\frac{\Gamma \vdash v : (t_1, \dots, t_n) \to int \quad \Gamma \vdash v_i : t_i}{\Gamma \vdash \lstinlineb{APP} \, v \, [v_1, \dots, v_n]} \\ \\
\frac{\Gamma \vdash v_1 : t_1 \quad \Gamma \vdash v_2 : t_2 \quad \Gamma, x : t \vdash e}{\Gamma \vdash \lstinlineb{ADD} \, v_1 \, v_2 \, x \, e} \\ \\
\frac{\Gamma \vdash v_i : t_i \quad \Gamma, x : [t_i, \dots, t_n] \vdash e}{\Gamma \vdash \lstinlineb{RECORD} \, [v_1, \dots, v_n] \, x \, e} \\ \\
\frac{\Gamma \vdash i : int \quad \Gamma \vdash v : [t_1, \dots, t_n] \quad \Gamma, x : t_i \vdash e}{\Gamma \vdash \lstinlineb{SELECT} \, i \, v \, x \, e} \\ \\
\frac{\Gamma \vdash v : t}{\Gamma \vdash \lstinlineb{DONE} \, v}
\end{gather*}

Since all our expressions do not return values, their typing judgements do not state types. The \lstinlineb{DONE} constructor could be argued to return a type, but we will interpret it as a constructor that halts computation and accepts a result.

% TODO
% cps relation to lambda calculus?

\section{\label{section:cpscomp}Alternatives to CPS}
% TODO
% compare cps to other IRs (just like in greendbook...) (LLVM (SSA), Haskell (Cmm), Java (bytecode))
% - data flow
% - closure conversion
% - semantics
There are many choices when it comes to \acp{IR}. We will take a look at a couple modern alternatives and compare them to \ac{CPS} to gain a more thorough understanding of why we picked it as an \ac{IR}. The \acp{IR} we will use for the comparison are:

\begin{itemize}
\item \textbf{SSA}\autocite{DBLP:journals/toplas/CytronFRWZ91}: used by LLVM\autocite{llvmlangref} compiler framework. In this \ac{IR} every variable is assigned exactly once. Variables need to be defined before it is used. When to control flows meet, an explicit transfer function is used to keep a resemblance to single assignment.
\item \textbf{Cmm}\autocite{DBLP:conf/ppdp/JonesRR99, haskellcmm}: used in the \ac{GHC}. Cmm is a high-level, portable assembly langauge that has a syntax similar to C.
\end{itemize}

An advantage of compiling functional languages or languages with functions to \ac{CPS} is that \ac{CPS} defines functions natively. We can translate functions to functions (with some conventions) in our \ac{CPS} language. In other \acp{IR} we will have to represent functions with lower-level constructs such as labels and jumps combined with a stack. \ac{CPS} in turn will have to encode lower-level constructs with functions.

\ac{CPS} is a prime candidate for inline expansion. Inline expansion substitutes function calls with function bodies with the respective variables in place. This operation is also known as beta-expansion.

Data flow analysis is essential to compilers.