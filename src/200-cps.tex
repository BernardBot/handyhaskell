% !TEX root = document.tex

\chapter{\label{chap:cps}Continuation-passing style}
% cps
% - is a programming style.
% - explicit control + data flow
% - adds cont arg
% - does not return
% - func args are values
\ac{CPS}\autocite{steel1975scheme} is a style of programming based on the use of continuations. In \ac{CPS} data flow and control flow are made explicit. Programming languages that support first-class functions, allow for programs written in \ac{CPS}. The primary difference from writing in the usual direct style is an extra argument for all functions called the continuation. The continuation represents the control flow and tells us 'what to do next' in a program. It may be implemented as a function. Functions written in \ac{CPS} do not return, instead they will call their continuation argument with certain parameters. Additionally, function parameters can only be values or functions. We can not apply a function to an expression that is not fully evaluated yet, e.g., an application expression. 

\begin{lstlisting}[language=Python]
def add(a, b):
  return a + b

def add_cps(a, b, k):
  k(a + b)           
\end{lstlisting}

% explain example
The basic differences between \ac{CPS} and direct style are shown by two addition functions. The first one is written in direct style and the other in \ac{CPS}. The differences are visible immediately: there is an extra argument \lstinlineb{k} and it replaces the \lstinlineb{return} in the function body. The \lstinlineb{+} operator is not written in \ac{CPS}. These kinds of operation are called primitives and are excluded from the \ac{CPS} conventions we described. Therefore, our rule of only applying functions to values does not have to be enforced. Other primitives include: all arithmetical operators, side-effects, and bitwise operators.

% NOT FINAL 
% introduce sections
We will show how to translate a controlf flow construct in \ac{CPS} in section \ref{section:dcflow}. Then in section \ref{section:cwc} we will elaborate on the use of \ac{CPS} as compilation paradigm. Finally, in section \ref{section:cpstype} we will discuss the types of \ac{CPS} and \ac{CPS} translations.

\section{\label{section:dcflow}Describing control flow}
% cps lambda calculus implementations (my blog post)
% - show power of cps
% - assembly in functional language vs. functional language in assembly...
To illustrate the power of \ac{CPS} we will implement forward jumps in the lambda calculus (with some primitives). The lambda calculus consists of abstractions, applications, and variables. Expressing an imperative operation such as jump seems impossible. By exposing continuations we will gain the power to model imperative style control flow. When compiling programs written in \ac{CPS} we will translate functions to label and jump instructions. We are now translating in the other direction, which will show the close relation between these two language constructs. The jumps we implement here will be conditional and take an extra argument that holds a return value. 

\begin{lstlisting}[language=Haskell]
-- functional imperativeness
jump = \ c r k1 k2 -> if c then k1 r else k2 r
label = \ f k -> f k k

-- continuation monad
unit = \ a k -> k a
bind = \ m f k -> m (\ a -> f a k)
\end{lstlisting}

Forward jumps are implemented by the \lstinlineb{jump} and \lstinlineb{label} functions. The \lstinlineb{jump} function takes two continuations \lstinlineb{k1} and \lstinlineb{k2}. The first continuation will represent the forward jump location in the program. The second continuation will represent the next instruction or normal continuation. In \ac{CPS} a jump is just a choice between two continuations. The \lstinlineb{label} function makes a copy of the current continuation and applies a function to both. This function \lstinlineb{f} will take an argument that represents the location to jump to. We will need some monadic machinery to sequence expressions. This is provided by the \lstinlineb{bind} and \lstinlineb{unit} functions\autocite{DBLP:conf/popl/Wadler92}.

% show and discuss some programs written with the previous defs
Now that our definitions are in place we can write programs with jumps. These programs will have to be in \ac{CPS}. The \lstinlineb{bind} and \lstinlineb{unit} functions will be used a lot. They can be hidden from the programmer by providing monadic sugar, but are provided here to show how a \ac{CPS} program works.

\begin{lstlisting}[language=Haskell]
-- cps translation of primitives
add = \ a b k -> k (a + b)
eq = \ a b k -> k (a == b)

program1 = label (\ end ->
  add 1 2      `bind` \ a ->
  eq a 3       `bind` \ b ->
  jump b a end `bind` \ c ->
  unit 42)
\end{lstlisting}

Our first program written in \ac{CPS} called \lstinlineb{program1} does the following: create a label \lstinlineb{end}; add the numbers 1 and 2 and bind the result to the variable \lstinlineb{a}; compare \lstinlineb{a} and the number 3 and bind the result to \lstinlineb{b}; if \lstinline{b} is true jump to the label \lstinlineb{end} with \lstinlineb{a} and bind the result to \lstinlineb{c}; return the number 42. As this program is in \ac{CPS} it will return a continuation, not a value. To extract a value we can use the lambda calculus. It allows us to apply the program to the identity function and in this case obtain the number 3 as result.

\section{\label{section:cwc}Compiling with continuations}
% cps better for compilation and harder to write, because
% - names of intermediates
% - function calls like gotos
\ac{CPS} is easier to compile (and mostly harder to write) than direct style, because \ac{CPS} resembles \ac{asm}. After evaluating an expression we call a function with the result, storing it in the respective argument of that function. This is similar to storing results of operations in registers. Since we do not have to save return addresses, our function calls are like \lstinlineb{goto} or \lstinlineb{jmp} statements. This is precisely what makes writing code in \ac{CPS} hard: we need to give all intermediate results names and state the order of evaluation in more detail.

% cps is a language that translates to well
We do not want to write our programs in \ac{CPS}, but we do want the advantages of \ac{CPS} in our compiler. We can have the best of both worlds and translate our language to \ac{CPS}. This is often not trivial. However, the flexible nature of continuations and the higher-level representation of functions gives us the tools we need. This function will have the task of naming all intermediate values and making control flow explicit. It will not come as a surprise that such a \ac{CPS} conversion function will itself be written in \ac{CPS}.

% cps is not a writing language, but a rewriting language
% - easy source to source
% - resembles control flow graph
% - has functions and records
\ac{CPS} is a language that is used as an \ac{IR} for compilers of functional languages\autocite{steele1978rabbit, DBLP:books/daglib/0022396}. \ac{CPS} itself can be representedd as a functional language. In this thesis we follow the \ac{CPS} language datatype definition by \citeauthor{DBLP:books/daglib/0022396} with some minor adjustments. This ensures the properties that are just conventions when writing in \ac{CPS}. The datatype is similar to the control flow graph of a program. Persistent data is modeled with records. The \ac{CPS} language is hard to write in, but easy to rewrite. Rewriting the \ac{IR} is exactly what our compiler does.

\begin{lstlisting}[language=Haskell]
type Var = String

data Val
  = VAR Var
  | NUM Int
  | LABEL Var

type Fun = (Var, [Var], Cexp)
data Cexp
  = FIX [Fun] Cexp
  | APP Val [Val]
  | ADD Val Val Var Cexp
  | RECORD [Val] Var Cexp
  | SELECT Int Val Var Cexp
  | DONE Val
\end{lstlisting}

%TODO
% compare cps to other IRs (just like in greendbook...) (LLVM (SSA), Haskell (G-machine), Java (bytecode))
% - data flow
% - closure conversion
% - semantics
There are many choices when it comes to \acp{IR}. We will take a look at a couple modern alternatives and compare them to \ac{CPS} to gain a more thorough understanding of why we picked it as an \ac{IR}.

%TODO
\section{\label{section:cpstype}Typing CPS}
% cps relation to lambda calculus?
% cps type system?