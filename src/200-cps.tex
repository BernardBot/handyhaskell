% !TEX root = document.tex

\chapter{\label{chap:cps}Continuation-passing style}
% cps
% - is a programming style.
% - explicit control + data flow
% - adds cont arg
% - does not return
% - func args are values
\ac{CPS}\autocite{steel1975scheme} is a style of programming based on the use of continuations. In \ac{CPS} data flow and control flow are made explicit. Programming languages that support first-class functions, allow for programs written in \ac{CPS}. The primary difference from writing in the usual direct style is an extra argument for all functions called the continuation. The continuation represents the control flow and tells us 'what to do next' in a program. It may be implemented as a function. Functions written in \ac{CPS} do not return, instead they will call their continuation argument with certain parameters. Additionally, function parameters can only be values or functions. We can not apply a function to an expression that is not fully evaluated yet, e.g., an application expression. 

\begin{lstlisting}[language=Python]
def add(a, b):
  return a + b

def add_cps(a, b, k):
  k(a + b)           
\end{lstlisting}

% explain example
The basic differences between \ac{CPS} and direct style are shown by two addition functions. The first one is written in direct style and the other in \ac{CPS}. The differences are visible immediately: there is an extra argument \lstinlineb{k} and it replaces the \lstinlineb{return} in the function body. The \lstinlineb{+} operator is not written in \ac{CPS}. These kinds of operation are called primitives and are excluded from the \ac{CPS} conventions we described. Therefore, our rule of only applying functions to values does not have to be enforced. Other primitives include: all arithmetical operators, side effects, and bitwise operators.

% NOT FINAL
% introduce sections
We will show how to translate a controlf flow construct in \ac{CPS} in section \ref{section:dcflow}. Then in section \ref{section:cwc} we will elaborate on the use of \ac{CPS} as compilation paradigm.
% Finally, in section \ref{section:cpstype} we will discuss the types of \ac{CPS} and \ac{CPS} translations.

\section{\label{section:dcflow}Describing control flow}
% cps lambda calculus implementations (my blog post)
% - show power of cps
% - assembly in functional language vs. functional language in assembly...
To illustrate the power of \ac{CPS} we will implement forward jumps in the lambda calculus (with some primitives). The lambda calculus consists of abstractions, applications, and variables. Expressing an imperative operation such as jump seems impossible. By exposing continuations we will gain the power to model imperative style control flow. When compiling programs written in \ac{CPS} we will translate functions to label and jump instructions. We are now translating in the other direction, which will show the close relation between these two language constructs. The jumps we implement here will be conditional and take an extra argument that holds a return value. 

\begin{lstlisting}[language=Haskell]
-- functional imperativeness
jump = \ c r k1 k2 -> if c then k1 r else k2 r
label = \ f k -> f k k

-- continuation monad
unit = \ a k -> k a
bind = \ m f k -> m (\ a -> f a k)
\end{lstlisting}

Forward jumps are implemented by the \lstinlineb{jump} and \lstinlineb{label} functions. The \lstinlineb{jump} function takes two continuations \lstinlineb{k1} and \lstinlineb{k2}. The first continuation will represent the forward jump location in the program. The second continuation will represent the next instruction or normal continuation. In \ac{CPS} a jump is just a choice between two continuations. The \lstinlineb{label} function makes a copy of the current continuation and applies a function to both. This function \lstinlineb{f} will take an argument that represents the location to jump to. We will need some monadic machinery to sequence expressions. This is provided by the \lstinlineb{bind} and \lstinlineb{unit} functions\autocite{DBLP:conf/popl/Wadler92}.

% show and discuss some programs written with the previous defs
Now that our definitions are in place we can write programs with jumps. These programs will have to be in \ac{CPS}. The \lstinlineb{bind} and \lstinlineb{unit} functions will be used a lot. They can be hidden from the programmer by providing monadic sugar, but are provided here to show how a \ac{CPS} program works.

\begin{lstlisting}[language=Haskell]
-- cps translation of primitives
add = \ a b k -> k (a + b)
eq = \ a b k -> k (a == b)

program1 = label (\ end ->
  add 1 2      `bind` \ a ->
  eq a 3       `bind` \ b ->
  jump b a end `bind` \ c ->
  unit 42)
\end{lstlisting}

Our first program written in \ac{CPS} called \lstinlineb{program1} does the following: create a label \lstinlineb{end}; add the numbers 1 and 2 and bind the result to the variable \lstinlineb{a}; compare \lstinlineb{a} and the number 3 and bind the result to \lstinlineb{b}; if \lstinline{b} is true jump to the label \lstinlineb{end} with \lstinlineb{a} and bind the result to \lstinlineb{c}; return the number 42. As this program is in \ac{CPS} it will return a continuation, not a value. To extract a value we can use the lambda calculus. It allows us to apply the program to the identity function and in this case obtain the number 3 as result.

% TODO
% more examples

% TODO
% cps self-interpreter
As a second example of the power of \ac{CPS}, we will show that it can be used to define a self-interpreter for the lambda calculus\autocite{DBLP:journals/jfp/Mogensen92}. It is based on the ability to define datatypes and pattern matching on these datatypes using \ac{CPS}. The translation function $\overline{\cdot}$ of a datatype is defined as:

\begin{equation*}
\overline{S_i (t_1 \dots t_m)} \equiv \lambda x_1 \dots x_n . x_i \, \overline{t_1} \dots \overline{t_m}.
\end{equation*}

The translation of the pattern match on this datatype is then defined as:

\begin{equation*}
\overline{\lstinlineb{CASE} \, s \, \lstinlineb{OF} \, S_1 \to e_1 \dots S_n \to e_n} \equiv \overline{s} \, (\lambda t_{1_1} \dots t_{1_m} . \overline{e_1}) \dots (\lambda t_{n_1} \dots t_{n_m} . \overline{e_n}).
\end{equation*}

We see that these translations use \ac{CPS} with a number of continuations equal to the number of constructors in a datatype. For our self-interpreter of the lambda calculus we will need three constructors: \lstinlineb{lam}, \lstinlineb{app}, and \lstinlineb{var}. Using our definitions we obtain:

\begin{lstlisting}[language=Haskell]
lam = \ f   lam app var -> lam f
app = \ f a lam app var -> app f a
var = \ x   lam app var -> var x

interp = \ e -> e 
  (\ f   -> \ x -> interp (f x))
  (\ f a -> interp e1 (interp e2))
  (\ x   -> x)
\end{lstlisting}

Note that we make recursive calls to the \lstinlineb{interp} function. This is not a native feature of the lambda calculus, but can be emulated by using the Y-combinator\autocite{barendregt1984lambda}.

\section{\label{section:cwc}Compiling with continuations}
% cps better for compilation and harder to write, because
% - names of intermediates
% - function calls like gotos
\ac{CPS} is easier to compile (and mostly harder to write) than direct style, because \ac{CPS} resembles \ac{asm}. After evaluating an expression we call a function with the result, storing it in the respective argument of that function. This is similar to storing results of operations in registers. Since we do not have to save return addresses, our function calls are like \lstinlineb{goto} or \lstinlineb{jmp} statements. This is precisely what makes writing code in \ac{CPS} hard: we need to give all intermediate results names and state the order of evaluation in more detail.

% cps is a language that translates to well
We do not want to write our programs in \ac{CPS}, but we do want the advantages of \ac{CPS} in our compiler. We can have the best of both worlds and translate our language to \ac{CPS}. This is often not trivial. However, the flexible nature of continuations and the higher-level representation of functions gives us the tools we need to tranlate almost any control flow contruct. \ac{CPS} conversion will have the task of naming all intermediate values and making control flow explicit. It will not come as a surprise that such a \ac{CPS} conversion function will itself be written in \ac{CPS}.

% cps is not a writing language, but a rewriting language
% - easy source to source
% - resembles control flow graph
% - has functions and records
\ac{CPS} is a language that is used as an \ac{IR} for compilers of functional languages\autocite{steele1978rabbit, DBLP:books/daglib/0022396}. \ac{CPS} itself can be representedd as a functional language. In this thesis we follow the \ac{CPS} language datatype definition by \citeauthor{DBLP:books/daglib/0022396} with some minor adjustments. This ensures the properties that are just conventions when writing in \ac{CPS}. The datatype is similar to the control flow graph of a program. Control flow is modeled with functions and function calls and persistent data is modeled with records. The \ac{CPS} language is hard to write in, but easy to rewrite. Rewriting the \ac{IR} is exactly what our compiler does.

\begin{lstlisting}[language=Haskell]
type Var = String

data Val
  = VAR Var
  | NUM Int
  | LABEL Var

type Fun = (Var, [Var], Cexp)
data Cexp
  = FIX [Fun] Cexp
  | APP Val [Val]
  | ADD Val Val Var Cexp
  | RECORD [Val] Var Cexp
  | SELECT Int Val Var Cexp
  | DONE Val
\end{lstlisting}

% explain cps datatype def
The \ac{CPS} language consist of values and expressions. This separation makes sure that the rule of functions only calling values is enforced. All expressions have a built-in continuation, except \lstinlineb{APP} and \lstinlineb{DONE}. Our expression tree has six constructors. The \lstinlineb{FIX} constructor provides recursive function definitions. The \lstinlineb{APP} constructor is for function application. Addition is represented by the \lstinlineb{ADD} constructor and our only primitive. \lstinlineb{RECORD} and \lstinlineb{SELECT} provide the necessary operations to modify record data on the heap. The \lstinlineb{DONE} constructor is new and not used by \citeauthor{DBLP:books/daglib/0022396}. It helps us to define the conversion function from a source language to \ac{CPS}. It cheats our \ac{CPS} conventions, because it represents a return statement. We will need to make sure that it is only used in the final continuation returning the value of our program. There are three value constructors for variable names, numbers, and function variable names. Making the distinction between variable names and function variable names helps us with the compilation of functions. 

% cps is untyped...
The absence of restrictions on variable names makes the \ac{CPS} datatype untyped. We can put a variable that represents an integer in function position of an application and the datatype would not complain. Undefined variable names can even be put in any value position. Being untyped makes it easy to manipulate the datatype, but also comes with more ways to go wrong. It is a double edged property. We can check if a \ac{CPS} program is well-typed by writing a function that traverses its expression tree while looking at the types of variable names and maintaining a list of their types. This would be an algorithmic implementation of a type system, called a type checker.

