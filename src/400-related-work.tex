% !TEX root = document.tex

\chapter{\label{chap:related-work}Related Work and Discussion}
In this chapter we will look at some of the theory behind the compilation scheme used in this thesis and discuss the shortcomings and improvements of our proposed command tree solution.

\section{\label{section:opmonad}The Operational Monad}
In this section we will derive the command tree monad and show how it relates to modular denotational semantics. We follow the style of the paper \citetitle{DBLP:conf/haskell/KiselyovI15} \autocite{DBLP:conf/haskell/KiselyovI15}, which gives a derivation of the freer monad, a close relative of the command tree. The main problem the command tree and its relatives address is: expressing side-effectful computation in a composable/modular manner. We will start by unpacking this definition.

A side-effect can be understood as an interaction of an expression with its context \autocite{DBLP:conf/tacs/CartwrightF94}. A concrete example is the communication between a number of clients and a central server. A side-effect is a request from a client to the server. This can be a request for some data or an action. From this it follows immediately that we can model side effects with data types that specify such a request. A trivial example is a ping request.

\begin{lstlisting}[language=Haskell]
data Request = Ping
\end{lstlisting}

The result of the ping request may be used in another part of the program. Our \icode{Request} data type does not indicate what the return type of a ping request will be. Moreover, there is no place where the reply of the request is bound. We can define a data type that helps us with both these problems. We will call it \icode{Compute}.

\begin{lstlisting}[language=Haskell]
data Compute = Done Int | Compute Request (Int -> Compute)
\end{lstlisting}

\icode{Compute} has two constructors that have the same role as those of the command tree. The \icode{Done} constructor represents a computation without side effects that returns an integer. \icode{Compute} binds \icode{Request}s together. The result of a request is an integer and may be used in the following computations. An example shows the data types in action. We send two sequential ping requests to the central server and bind them to the variables \icode{i} and \icode{j}. Finally, we return the average of both. How a ping request is actually implemented is left open. \icode{Request} just provides the interface for effectful computation.

\begin{lstlisting}[language=Haskell]
pingtwiceavg = Compute Ping (\ i -> Compute Ping (\ j -> Done ((i + j) `div` 2)))
\end{lstlisting}

This way of defining sequences of effectful computations is called operational \autocite{operationalmonad}. It is an alternative to other monadic implementations of side-effects. The upside of operational monads is their compositional nature. Traditional implementation of side-effects such as monad transformers \autocite{DBLP:conf/popl/LiangHJ95} also compose, but suffer from non-commutative behavior \autocite{DBLP:conf/ifl/DayH13}.

Haskell provides typeclasses for defining monads. These are similar to an interface. Our \icode{Compute} data type does not qualify for these, because Haskell requires monads to be parameterized over a type. We define our own \icode{bind} function, which composes two computations; the \icode{unit} function creates a trivial computation. In the implementation of the \icode{bind} function we see that it pushes a function from an integer to a computation into the continuation of a computation. This is similar to list concatenation.

\begin{lstlisting}[language=Haskell]
bind (Done i)      f = f i
bind (Compute r k) f = Compute r (\ i -> bind (k i) f)
-- unit is trivial
unit = Done
\end{lstlisting}

With our monadic definitions in place we can create a pretty version of our previous program that takes the average ping. We will define a helper function that represent a program that sends a ping request and returns the result. This enables us to \icode{bind} these smaller programs together.

\begin{lstlisting}[language=Haskell]
ping = Compute Ping Done

prettyping =
  ping `bind` \ i ->
  ping `bind` \ j ->
  unit ((i + j) `div` 2)
\end{lstlisting}

If we substitute our requests for commands and add subcontinuations to \icode{Compute} we obtain our command tree. In the next subsection we will derive command trees in another way with the free monad.

\subsection{\label{subsection:freemonad}Free Monad}
Both the command tree and the \icode{Compute} data type are a specialization of the free monad \autocite{swierstra2008data}. The free monad arises naturally when composing functors. In mathematical terms a functor is a mapping between categories \autocite{barr1990category}. In practical terms a functor is something that can be mapped over. A list is an example of a functor. We will take as our example functor a modified version of the \icode{Maybe} data type and show what happens when we compose it with itself \autocite{freemonadsforall}. It describes a programming language where we either \icode{Stop} with execution or sound a \icode{Bell} and continue.

\begin{lstlisting}[language=Haskell]
data Program a = Stop | Bell a

p0 :: Program (Program a)
p0 = Bell Stop

p1 :: Program (Program (Program a))
p1 = Bell (Bell Stop)
\end{lstlisting}

We see that our type grows with our expression. Both \icode{p0} and \icode{p1} should have the type \icode{Program a}. We want a function of type \icode{Program (Program a) -> Program a} that removes the nesting of functors. What we need is a fixpoint of a functor.

\begin{lstlisting}[language=Haskell]
data Fix f where
  Fix :: f (Fix f) -> Fix f
\end{lstlisting}

The type of \icode{Fix} reflects the type of the function that we wanted. Our new programs will be of type \icode{Fix Program}.

\begin{lstlisting}[language=Haskell]
fp0 :: Fix Program
fp0 = Fix (Bell (Fix Stop))

fp1 :: Fix Program
fp1 = Fix (Bell (Fix (Bell (Fix Stop))))
\end{lstlisting}

\icode{Fix} is almost a monad. What we need is a generic way to terminate programs. We will also need to parameterize over the return type instead of a functor. This leads us to the free monad.

\begin{lstlisting}[language=Haskell]
data Free f a where
  Pure   :: a            -> Free f a
  Impure :: f (Free f a) -> Free f a
\end{lstlisting}

The free monad is thus a way to nest a functor, while maintaining a basic type of that functor. The free monad is restricted by this functor requirement. Without it, it is not a monad. Command trees do not have this requirement. We use a wrapper for our commands that ensures they are functors. This wrapper is a complex functor, but the principle is based on a simpler concept: pretending a mapping happened. The data type that captures this notion is the functor by construction \icode{F}. It consists of something resembling a functor and a mapping over the contents of this fake functor. Whenever we map over \icode{F}, we simply compose with the second argument. We pretend something happened; we update our mapping function.

\begin{lstlisting}[language=Haskell]
data F f a where
  F :: f a -> (a -> b) -> F f b

instance Functor (F f) where
  fmap g (F f h) = F f (g . h)
\end{lstlisting}

If we extend this idea to the free monad we obtain the freer monad. The functor \icode{Tps} uses is of a more specialized nature related to \icode{Cps} and \icode{Val}.

\begin{lstlisting}[language=Haskell]
data G f a where
  G :: f -> [Val] -> (Val -> b) -> G f b

instance Functor (G f) where
  fmap g (G f ks k) = G f ks (g . k)
\end{lstlisting}

Command trees can thus also be derived from the free monad which itself arises when we nest functors. In this and the previous subsection we have shown that command trees arise when we want to model requests or nest functors. This corresponds nicely to the objectives of modular denotational semantics where we work with semantic language modules that may have effects.

\section{\label{section:denotationalsemantics}Modular Denotational Semantics}
In this section we will give a short introduction to modular denotational semantics and then show how it relates to the work on the LamToWat compiler in this thesis. We will begin by stating some definitions. Denotational semantics is a method of giving meaning to programs by constructing mathematical objects which we often call 'values'. A programming language consists of multiple interacting parts called 'terms', like a function module or an arithmetic module. Terms can be given corresponding values separately. Then the meaning of the combined modules which make up a language is simply the sum or composition of these mappings. Originally there have been two popular approaches to solving this problem: algebraic effects \cite{DBLP:conf/tacs/CartwrightF94} and monad transformers \cite{DBLP:conf/popl/LiangHJ95}. To give meaning to a program we write a program called an 'interpreter' that maps terms in each module to their respective denotation.

A denotational semantics is made up of three things: terms, values, and effects. We represent all three with Haskell constructs. A semantics is modular when we are able to split and extend all three components. In Haskell open unions give us the power to do this for terms and values. To model effects we will need monads: either monad transformers or the free monad depending on which approach we choose. % They arise as a solution to the unstable denotation problem.

Now we will give an example of a modular denotational semantics for a simple language that can manipulate one memory cell \icode{fetch, set} and do addition \icode{add, int}. We will illustrate the relation between monad transformers and algebraic effects \cite{DBLP:conf/haskell/SchrijversPWJ19}. One can be translated into the other and vice-versa. Both approaches allow one to construct an interpreter for our toy language. We will use Haskell typeclasses to represent modular interfaces for terms and highlight the relation by providing instances for both. The typeclasses are defined as follows

\begin{lstlisting}[language=Haskell]
class Cell d where
  fetch :: d
  set :: d -> d

class Addition d where
  add :: d -> d -> d
  int :: Int -> d
\end{lstlisting}

The domain of our language will simply be Haskell integers \icode{Int}. We said before that our domain must also be extendible, we can also do that here by using open unions and describing integers as an element of the union like so: \icode{Int :<: dom => ... dom ...}. However, this would lead to syntactic overhead which would only hinder the illustrative purposes of this example.

The monad transformer approach uses the state monad transformer to implement the effects of the \icode{Cell} typeclass. It is included in the \icode{mtl} package and is defined as follows, where \icode{s} is the type of the internal state, \icode{m} is a monad, and \icode{a} is the return type.

\begin{lstlisting}[language=Haskell]
newtype StateT s (m :: * -> *) a = StateT {runStateT :: s -> m (a, s)}
\end{lstlisting}

We can supply (modular) instances for both our typeclasses by adding a \icode{MonadState} constraint, which is a typeclass in itself. This means that we get access to the operations \icode{get, put}, which are very similar to \icode{fetch, set}.

\begin{lstlisting}[language=Haskell]
instance MonadState Int m => Cell (m Int) where
  fetch = get
  set d = do
    d' <- d
    put d'
    return d'

instance MonadState Int m => Addition (m Int) where
  add a b = do
    i <- a
    j <- b
    return (i + j)
  int = return
\end{lstlisting}

The Algebraic Effects approach requires a bit more preliminary work, because the monad is not taken from a package. We first define a new version of the operational/free monad that is specific to our domain of integers. We also define two command representing the \icode{get, put} from the state monad transformer. We create smart constructors for both called \icode{get'} and \icode{put'}, respectively.

\begin{lstlisting}[language=Haskell]
data Freer' cmd d where
  Pure :: d -> Freer' cmd d
  Impure :: cmd -> (Int -> Freer' cmd d) -> Freer' cmd d

data Cmd = Get | Put Int
\end{lstlisting}

We can now give instances for our typeclasses, which look almost the same. We now contrain our commands instead of an effect typeclass.

\begin{lstlisting}[language=Haskell]
instance Cmd :<: cmd => Cell (Freer' cmd Int) where
  fetch = get'
  set d = do
    d' <- d
    put' d'
    
instance Cmd :<: cmd => Addition (Freer' cmd Int) where
  add a b = do
    i <- a
    j <- b
    return (i + j)
  int = return
\end{lstlisting}

We will also have to define a handler for \icode{Cmd} commands called \icode{hCmd} as follows.

\begin{lstlisting}[language=Haskell]
hCmd :: Cmd :<: cmd => Freer' cmd a -> Int -> Freer' cmd (a, Int)
hCmd (Pure d)       s = Pure (d,s)
hCmd (Impure cmd k) s = case prj cmd of
  Just Get     -> hCmd (k s) s
  Just (Put s) -> hCmd (k s) s
  _            -> Impure cmd (\ d -> hCmd (k d) s)
\end{lstlisting}

% CONCLUSION comparison
We see that both approaches allow us to define instances for our language terms modularly. Both approaches use constraints to make the instances modular: monad transformers use typeclass constraints, while algebraic effects use contraints on the open union of commands.

Why did we use modular denotational semantics to write a compiler? Denotational semantics are very useful because they lead to a method of proving equality of terms of a language. When two terms have the same denotational value, they have the same meaning and one can be replaced by the other. This gives rise to many optimizations, which are provably correct.

One of the goals of a compiler is to optimize code, thus one can see where denotational semantics comes in. Moreover, it is important that the meaning of a program is not changed during compilation. In this thesis we have tried to extend this concept of denotational semantics from interpreters to compilers. In the first version of the compiler we used the approach of monad transformers. In the second version we used algebraic effects represented by command trees.

\section{Relation of CPS and Command Trees}
Command trees are very similar to \icode{Cps} and some of the features command trees provide can be emulated by extending \icode{Cps}. The added value of command trees is better pattern matching and more flexibility in the commands it uses. However, in the LamToWat implementation we choose commands that match \icode{Cps} almost one-to-one. The IR transformations remain mostly the same. One could argue that the command trees should be compiled to a modular version of \icode{Cps} instead, allowing for reuse of the original compiler code. This could provide an improved front-end of the compiler with a \icode{Cps} based back-end. We can split \icode{Cps} into a front-end part and a back-end part. The front-end would be monadic and have effects for generating fresh variables and getting and setting continutations. It would be defined as follows.

\begin{lstlisting}[language=Haskell]
data Cps a
  = DONE a
  | APP Val [Val]
  | ADD Val Val (Val -> Cps a)
  | RECORD [Val] (Val -> Cps a)
  | SELECT Int Val (Val -> Cps a)
  | FIX [(String,[String],Cps Val)] (Cps a)
  -- embedded effects
  | FRESH String (String -> Cps a)
  | GETK (Val -> Cps a)
  | SETK Val (Cps a)
  | BLOCK (Cps Val) (Val -> Cps a)
\end{lstlisting}

Our original constructors are here combined with embedded effects. These effects were represented by monad transformers in the first version in the compiler and with the two command modules \icode{Fresh} and \icode{Block} in the second version. Embedding them inside gives us all the features of a command tree without overhead of projecting and injecting commmands. The continuations of \icode{ADD,RECORD,SELECT} have been changed to be semantic and have type \icode{Val -> Cps a} instead of being syntactic and binding their names directly. We (monadic) bind expressions together by entering their continuation. For example the monadic bind of \icode{ADD} is defined as \icode{ADD v1 v2 k >>= f = ADD v1 v2 (\ x -> k x >>= f)}. We can define the same smart constructors as for the command tree. If we take \icode{ADD} as example again we get the constructor by combining it with \icode{DONE}: \icode{add v1 v2 = ADD v1 v2 DONE}.

\begin{lstlisting}[language=Haskell]
data Base a
  = ADD' Val Val String a
  | APP' Val [Val]
  | DONE' Val

data Record a
  = RECORD' [Val] String a
  | SELECT' Int Val String a

data Fun a
  = FIX' [(String, [String], a)] a
\end{lstlisting}

The back-end of will consist of three data types, which represent the different modules of \icode{Cps}. We combine these with a different version of the open unions we discussed in subsection \ref{subsection:openunion} and the functor fixpoint \icode{Fix} from subsection \ref{subsection:freemonad}. For the back-end we do use smart constructors to inject and project our data type.

The compiler steps will look like a combination of the first and second version of the compiler with an additional step that translates between the two \icode{Cps} partitions. We are now able to indicate what the steps really do, by pattern matching on one specific part and having declarative types.
