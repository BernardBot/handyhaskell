% !TEX root = document.tex

\chapter{\label{chap:bettercompiler}The improved LamToWat compiler}
In the previous section we introduced command trees and showed their problematic properties as an \ac{IR}. In this chapter we propose syntactic command trees as a solution to this problem and show how it is implemented in a new version of the LamToWat compiler. Syntactic command trees have, as their name implies, syntactic representation of name binding in their constructors. The dependent types are dropped to make non-local transformations of the tree manageable. Dependently typed vectors will be replaced with lists and the dependently type \lstinlineb{Option} will be replaced with \lstinlineb{Maybe}. The only types that remain in the signature are the argument \lstinlineb{p} and return type \lstinlineb{r} of the subcontinuations. We require a function to translate from our command trees (now also called semantic command trees) to syntactic command trees. Moreover, a new set of commands need to be made for the syntactic trees.

\begin{lstlisting}[language=Haskell]
data Tree sig a where
  Leaf :: a -> Tree sig a
  Node :: sig p r ->
          [(p, Tree sig r)] ->
          Maybe (Var, Tree sig a) ->
          Tree sig a
\end{lstlisting}

\section{\label{section:syncomtree}Syntactic CPS commands}
The set of syntactic \ac{CPS} commands does no longer require the commands related to compilation. These commands are given a syntactic representation within the tree. Therefore, our set of commands will match the original \ac{CPS} commands almost completely. With the exception of the \lstinlineb{DONE} expression.

\begin{lstlisting}[language=Haskell]
type Sig = * -> * -> *

data Fun :: Sig where
  Fix :: [(Var,[Var])] -> Fun () Val

data Kon :: Sig where
  App :: Val -> [Val] ->  Kon Void Void
  Plus :: Val -> Val ->   Kon Void Void
  Record :: [Val] ->      Kon Void Void
  Select :: Int -> Val -> Kon Void Void
\end{lstlisting}

The commands are separated into two datatypes. This separation is made with the compilation steps that follow in mind, which are mainly concerned with transforming functions.

\subsection{\label{section:openunion}Open unions}
We will combine \lstinlineb{Fun} and \lstinlineb{Kon} using an open union or sum data type. An open union can be viewed as a list of datatypes. More precisely, it is a binary tree which has datatypes as leaf nodes. \lstinlineb{:+:} is right-associative and has two constructors \lstinlineb{Inl} and \lstinlineb{Inr}, which inject a datatype with two type variable into the left or right side of the tree, respectively. Note that we can nest instances of open unions to create open unions. In order to extract a datatype from an open union we simply pattern match on the two constructors. Our new \lstinlineb{Cmd} will have \lstinlineb{Fun} in its right subtree and \lstinlineb{Kon} in its left subtree.

\begin{lstlisting}[language=Haskell]
infixr 5 :+:
data (:+:) :: Sig -> Sig -> Sig where
  Inl :: sig1 p r -> (sig1 :+: sig2) p r
  Inr :: sig2 p r -> (sig1 :+: sig2) p r

type Cmd = Fun :+: Kon
\end{lstlisting}

%TODO more stuff about open unions...

\section{\label{section:semtosyn}Transforming semantic command trees into syntactic command trees}
The transformation from semantic command trees into syntactic command trees eliminates the extra 'compilation' commands from the command tree and instantiates name binding commands with generated variables. The transformation is called \lstinlineb{compile} and is performed using a special monad \lstinlineb{M}. The monad \lstinlineb{M} provides a number that is used as a posfix for generating fresh variable names and an environment function that maps variables to values. Our \lstinlineb{compile} function will be written in monadic style. We will pattern match on each of the semantic commands to tranform them.

\begin{lstlisting}[language=Haskell]
newtype M a = M { runM :: Int -> (Var -> Val) -> (Int, a) }
\end{lstlisting}

We will take a look at transforming the semantic \lstinlineb{Fresh} variable command and the \lstinlineb{Plus} command into syntactic command trees. The compilation of the \lstinlineb{Fresh} command seems trivial, because we use the helper function \lstinlineb{fresh}. This helper function should not be confused by the sugared version of the \lstinlineb{Fresh} command. This function updates the state integer of \lstinlineb{M} and returns a fresh variable (in this case a string). The compilation of \lstinlineb{Plus} shows the instantiation of variables in the metalanguage with variables in the syntactic command trees. We generate a fresh variable, pass it to the continuation and compile the continuation, and finally plug the result into the syntactic command tree.

\begin{lstlisting}[language=Haskell]
comp :: S.Tree S.Cmd Val -> M (Tree Cmd Val)

comp (S.Node (S.Fresh x) Nil (Some k)) = do
  x <- fresh x
  comp (k x)

comp (S.Node (S.Plus v1 v2) Nil (Some k)) = do
  x <- fresh ".xl"
  k <- comp (k (VAR x))
  return (Node (Inr (Plus v1 v2)) [] (Just (x, k)))
\end{lstlisting}

% TODO
% better, more...

\section{\label{section:compcomtree}Compiling with command trees}
We have introduced new constructs to improve our baseline compiler, which have changed the organization of our compiler. The improved LamToWat compiler has one additional step compared to its baseline version: transforming semantic command trees into syntactic command trees. The internal datatype used is changed from \ac{CPS} to a combination of semantic and syntactic command trees.

% TODO insert compilation pipeline new

We have claimed to solve the problem posed in section \ref{section:transcomtree}. The free defined variable function \lstinlineb{dv} can now be implemented without having to generate variables. We look at the case for addition and note that we only pattern match on the constructor of the sum type. This is because the four expressions in the \lstinlineb{Kon} datatype have the same behavior in the \lstinlineb{dv} function. Our pattern match is more elaborate than the one on the \ac{CPS} datatype, but in return this reveals more information about the expression.

\begin{lstlisting}[language=Haskell]
dv (Node (Inr _) _ (Just (x, k))) xs = dv k (x:xs)
\end{lstlisting}

The next compilation step is closure conversion proper. This transformation does not change a lot. There is a small improvement made: just as with the free defined variable function we can bundle the behavior of some of the \lstinlineb{Kon} expressions. This holds the same for the hoisting of \lstinlineb{Fix} expressions. The emit steps is largely the same as well. The distinction between \lstinlineb{Kon} expression does need to be made here, because each expression translates differently to abstract \ac{WA}. Our auxiliary local variable function does get the same pattern match improvement.

% TODO