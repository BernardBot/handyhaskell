% !TEX root = document.tex

\chapter{\label{chap:cpscomp}Compiling With Continuations}
In this chapter we will develop the LamToWat compiler that translates the lambda calculus into WebAssembly \autocite{webassemblyhomepage}. Our compiler will be written in Haskell \autocite{haskellhomepage}. We follow a minimal version of the approach by \citeauthor{DBLP:books/daglib/0022396}. Consequently, \ac{CPS} will be the \ac{IR}. The purpose of building LamToWat is to examine and then improve its \ac{IR}. Although we are not concerned with the peripherals of the compiler, an \ac{IR} is not used in a vacuum. We want to examine the compiler steps that map to and from the \ac{IR} as well as the ones that map to the \ac{IR} itself. If we can improve upon the already favorable features of \ac{CPS}, we are creating a better IR to program in.

What makes \ac{CPS} favorable as an \ac{IR} is that it makes control flow and data flow explicit. These features nicely represent the objective of a compiler. The process of translating from a high-level to a low-level language can be viewed as describing abstractions in finer detail. \ac{CPS} uses continuations to describe more complex control flow constructs. Continuations are more abstract than the \icode{label} and \icode{jump} instruction pair found in assembly language. This becomes essential when translating languages with first-class functions.

LamToWat is a multipass compiler. This means that multiple passes over the \ac{IR} will be made, each transforming a part of the representation. The complete compiler comprises these \ac{IR} transformations with additional passes to read in source files and print the resulting \ac{WA}.

\begin{equation*}
  String \xrightarrow{lexify} Token \xrightarrow{parsify} Exp \xrightarrow{cpsify} Cexp \xrightarrow{closify} Cexp \xrightarrow{hoist} Cexp \xrightarrow{emit} Wmodule \xrightarrow{show} String
\end{equation*}

LamToWat is split into a front-end and a back-end. The front-end of the compiler is made up of lexing, parsing, and \ac{CPS} conversion. We will not discuss lexing and parsing in detail, as it is irrelevant to the research in this thesis. We use \lstinlineb{Alex}\autocite{haskellalex} and \lstinlineb{Happy}\autocite{haskellhappy} to generate both a lexer and a parser for our compiler, respectively. The lexer converts source files into tokens and the parser in turn converts these tokens into an \ac{AST}. The back-end of LamToWat consist of three transformations on the \ac{IR}: closure conversion, hoisting, and emitting.

The following sections will first describe the datatypes used in LamToWat with extra attention to the \ac{CPS} \ac{IR}. Then we will adhere to the organization of the compiler and discuss the relevant compiler passes over these datatypes in order.

\section{\label{section:datatypes}Data Types}
The datatypes of LamToWat will be implemented as Haskell datatypes. Haskell data types are indicated with the \icode{data} keyword. Every datatype has a name, which comes after the keyword. Then a number of constructors follow separated by vertical bars. Datatypes can be recursively defined. Type aliases indicated with the \icode{type} keyword are also used; providing new names for already declared datatypes.

\subsection{\label{subsection:expdata}Lambda Calculus}
The \icode{Exp} datatype represents the \ac{AST} of the lambda calculus. The three constructors for \icode{Abs}traction, \icode{App}lication, and \icode{Var}iables encompass the standard definition of the lambda calculus. Two constructors for \icode{Num}bers and \icode{Add}ition are added to make basic arithmetic possible. Although the language is very small it does support first-class functions and recursion. Moreover, the lambda calculus is well-studied \autocite{barendregt1984lambda} and many pathological programs exist.

\begin{lstlisting}[language=Haskell]
type Var = String

data Exp
  = Abs Var Exp
  | App Exp Exp
  | Var Var
  | Num Int
  | Add Exp Exp
\end{lstlisting}

\subsection{\label{subsection:cpsdata}CPS Language}
In this thesis we follow the \ac{CPS} language datatype definition by \citeauthor{DBLP:books/daglib/0022396} with some minor adjustments. It is used as \ac{IR} because it facilitates compiler transformations relevant to functional programming languages. The datatype is similar to the control flow graph of a program. Control flow is modeled with functions and function calls. Data flow is modeled with records. LamToWat uses \ac{CPS} to transform nested, higher-order functions to simple functions.

The \icode{CPS} datatype guarantees that compiler transformations can be easily implemented by enforcing the following properties.

\begin{itemize}
\item Functions have an extra argument called the 'continuation'.
\item Functions do not return, instead the last thing a function does is call a continuation.
\item Function parameters can only be values.
\item All intermediate values have names.
\end{itemize}

\icode{CPS} functions are made up of a name, argument names, and a body. They are defined in mutually recursive \icode{FIX}ed function blocks. Values are either \icode{NUM}bers, \icode{VAR}iables, or \icode{LABEL}s. \icode{LABEL}s are used for proper function names appearring in \icode{FIX}es, \icode{VAR}iables for everything else including continuations. The \icode{CPS} language enforces the the distinction between \icode{Val}ues and \icode{Cexp}ressions by putting them in separate datatypes. All expressions except \icode{APP} and \icode{DONE} have a continuation as their last argument. Since the \icode{ADD}, \icode{RECORD}, and \icode{SELECT} expressions produce a value, they name it before continuing. \icode{DONE} helps us to define the function that translates a source language into \ac{CPS}. As this expression represents a return statement, it violates the second property of \ac{CPS}. No problems are cause by it, because we will make sure that the it is the final expression of our programs. This makes it a global return of the program itself, not of a function.

Variable names in \ac{CPS} are syntactically represented by simple strings. This is a design choice as it allows for nonsense programs that use undefined variables, but also for easy manipulation of variables and generation of variable names.

\begin{lstlisting}[language=Haskell]
type Var = String

data Val
  = VAR Var
  | NUM Int
  | LABEL Var

type Fun = (Var, [Var], Cexp)
data Cexp
  = FIX [Fun] Cexp
  | APP Val [Val]
  | ADD Val Val Var Cexp
  | RECORD [Val] Var Cexp
  | SELECT Int Val Var Cexp
  | DONE Val
\end{lstlisting}

\subsection{\label{subsection:webdata}WebAssembly Language}
The WebAssembly language is a typed, hierarchical, high-level assembly language and a subset of WebAssembly. As the final language in the compilation process it gives some guarantees about the well-formedness of the output of the compiler. The fundamental unit of code is a \icode{Wmodule} made up of a list of \icode{Wtexp}s. A \icode{Wtexp} is made up of \icode{Wexp}s.

\icode{I32_Const}, 32-bit integers are the basic values, used as both numbers and pointers. \icode{Func}tions are defined at the module level and can not be nested. They take zero or more arguments to a result as declared in their type signature. Local variables used in a function's body are also declared in its signature and can be \icode{LocalSet} and \icode{LocalGet}. All function calls are indirect, meaning that the function a variable points to is resolved at runtime. A \icode{Table} with type signature \icode{Elem}ents for the called functions is required at compile time. Persistent \icode{Memory} is allocated statically and its data can be \icode{Load}ed and \icode{Store}d. A \icode{GlobalDef}ined variable can be used in the entire module, it has a \icode{GlobalType} and can be \icode{GlobalSet} and \icode{GlobalGet}. The only \icode{Primop}eration is addition.

\begin{lstlisting}[language=Haskell]
type Size = Int
type Offset = Int
type Var = String

data GlobalType = Mut Wtype | Immut Wtype
data Wtype = I32

data Wmodule = Wmodule [Wtexp]

data Wtexp
  = Func Var [(Var, Wtype)] Wtype [(Var, Wtype)] [Wexp]
  | TypeDef Var [Wtype] Wtype
  | GlobalDef Var GlobalType Wexp
  | Memory Size
  | Table Size
  | Elem Wexp [Var]
  | Export Var Var

data Wexp
  = I32_Const Int
  | Return Wexp
  | LocalGet Var
  | LocalSet Var Wexp
  | GlobalGet Var
  | GlobalSet Var Wexp
  | Type Var
  | Call_Indirect Wexp Wexp [Wexp]
  | Return_Call_Indirect Wexp Wexp [Wexp]
  | Primop Wop [Wexp]
  | Load Offset Wexp
  | Store Offset Wexp Wexp

data Wop = PLUS
\end{lstlisting}

\section{\label{section:transforms}Transformations}
\subsection{\label{subsection:cpsconvert}CPS Conversion}
\subsection{\label{section:closconvert}Closure Cconversion}
\subsection{\label{subsection:hoist}Hoisting}
\subsection{\label{section:emit}Emitting}
